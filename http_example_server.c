#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <string.h>
#include "httpd.h"
#include "httpd_priv.h"

/*
** This is a static page of HTML. It is loaded into the content
** tree using httpdAddStaticContent().
*/
#define test1_html "<HTML><BODY>This is just a test</BODY>"


/*
** Below are 2 dynamic pages, each generated by a C function. The first
** is a simple page that offers a little dynamic info (the process ID)
** and then sets up a test link and a simple form.
**
** The second page processes the form. As you can see, you can access
** the form data from within your C code by accessing the symbol table
** using httpdGetVariableByName() (and other similar functions). You
** can also include variables in the string passed to httpdOutput() and
** they will be expanded automatically.
*/
void index_html(server, request)
    httpd   *server;
    httpReq *request;
{
    httpdPrintf(server, request, "Welcome to the httpd server running in process number %d<P>\n", getpid());
    httpdPrintf(server, request, "Click <A HREF=/test1.html>here</A> to view a test page<P>\n");
    httpdPrintf(server, request, "<P><FORM ACTION=test2.html METHOD=POST>\n");
    httpdPrintf(server, request, "Enter your name<INPUT NAME=name SIZE=10>\n");
    httpdPrintf(server, request, "<INPUT TYPE=SUBMIT VALUE=Click!><P></FORM>\n");
    return;
}

struct FileContent {
    unsigned long length;
    char *buffer;
};

struct FileContent read_file(char *name) {
    FILE *file;
    char *buffer;
    unsigned long fileLen;
    struct FileContent result;

    //Open file
    file = fopen(name, "rb");
    if (!file) {
        fprintf(stderr, "Unable to open file %s", name);
        return;
    }
    
    //Get file length
    fseek(file, 0, SEEK_END);
    fileLen=(ftell(file));
    printf("fileLen: %d\n", fileLen);
    fseek(file, 0, SEEK_SET);

    //Allocate memory
    buffer=(char *)malloc((fileLen)+1);
    if (!buffer) {
        fprintf(stderr, "Memory error!");
        fclose(file);
        return;
    }

    //Read file contents into buffer
    fread(buffer, fileLen, 1, file);
    fclose(file);

    result.length = fileLen;
    result.buffer = buffer;

    //Do what ever with buffer

    // free(buffer);
    return result;
}

void jpeg_handler(httpd *server, httpReq *request) {
    httpdSetContentType(server, request, "image/jpeg");
    httpdSendHeaders(server, request);
    struct FileContent buffer;
    buffer = read_file("../example.jpeg");
    printf("buffer length: %d\n", buffer.length);
    request->response.responseLength += buffer.length;
    _httpd_net_write(request->clientSock, buffer.buffer, buffer.length);
    // free(&buffer); // *** Error in `./http_example_server': double free or corruption (out): 0x00007ffd72cd9580 ***
    return;
}

int nsleep(long miliseconds) {
    struct timespec req, rem;

    if(miliseconds > 999)
    {   
        req.tv_sec = (int)(miliseconds / 1000);                            /* Must be Non-Negative */
        req.tv_nsec = (miliseconds - ((long)req.tv_sec * 1000)) * 1000000; /* Must be in range of 0 to 999999999 */
    }   
    else
    {   
        req.tv_sec = 0;                         /* Must be Non-Negative */
        req.tv_nsec = miliseconds * 1000000;    /* Must be in range of 0 to 999999999 */
    }   

    return nanosleep(&req , &rem);
}


void mjpeg_handler(httpd *server, httpReq *request) {
    printf(">>>>>> mjpeg_handler start\n");
    httpdSetContentType(server, request, "multipart/x-mixed-replace;boundary=\"mjpegstream\"");
    httpdAddHeader(server, request, "Cache-Control: no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0");
    // httpdAddHeader(server, request, "Content-Type: multipart/x-mixed-replace;boundary=--boundary");
    httpdAddHeader(server, request, "Pragma: no-cache");
    // httpdAddHeader(server, request, "Connection: close");
    httpdSendHeaders(server, request);
    // httpdSetResponse(server, request, "200 OK");

    struct FileContent buffer, buffer_0;
    buffer = read_file("../example.jpeg");
    buffer_0 = read_file("../example_0.jpeg");
    // printf("buffer length: %d\n", buffer.length);
    for (int i = 0; i < 100; i++) {
        printf("frame: %04d\n", i);
        char * header = (char *)malloc((150)+1);
        if (i % 2 == 0) {
            sprintf(header, "\r\n--mjpegstream\r\nContent-Type: image/jpeg\r\nContent-Length: %d\r\nImage-Id: %d\r\n\r\n", buffer.length, i);
            _httpd_net_write(request->clientSock, header, strlen(header));
            _httpd_net_write(request->clientSock, buffer.buffer, buffer.length);
            // request->response.responseLength += strlen(header);
            // request->response.responseLength += buffer.length;
            _httpd_net_write(request->clientSock, "\r\n", 2);
        } else {
            sprintf(header, "\r\n--mjpegstream\r\nContent-Type: image/jpeg\r\nContent-Length: %d\r\nImage-Id: %d\r\n\r\n", buffer_0.length, i);
            _httpd_net_write(request->clientSock, header, strlen(header));
            _httpd_net_write(request->clientSock, buffer_0.buffer, buffer_0.length);
            // request->response.responseLength += strlen(header);
            // request->response.responseLength += buffer_0.length;
            _httpd_net_write(request->clientSock, "\r\n", 2);
        }
        printf("%s\n", header);

        free(header);
        // struct timespec interval; // = {0, 500000000L};
        // interval.tv_sec = 0;
        // interval.tv_nsec = 500000000L;
        // const struct timespec * req = &interval;

        // printf("nanosecond: %d\n", interval.tv_nsec);
        // nanosleep(req, NULL);
        // nanosleep((const struct timespec[]){{0, 500000000L}}, NULL);

        nsleep(30);
        // printf("sleep result: %d\n", ret);
    }
    // httpdPrintf(server, request, "<P>this is a mjpeg page</P>\n");
    // return;
    free(buffer.buffer);
    free(buffer_0.buffer);
    printf(">>>>>> mjpeg_handler end\n");
}

void test2_html(server, request)
    httpd   *server;
    httpReq *request;
{
    httpVar *variable;
    /*
    ** Grab the symbol table entry to see if the variable exists
    */
    variable = httpdGetVariableByName(server, request, "name");
    if (variable == NULL)
    {
        httpdPrintf(server, request, "Missing form data!");
        return;
    }

    /*
    ** Use httpdOutput() rather than httpdPrintf() so that the variable
    ** embedded in the text is expanded automatically
    */
    httpdOutput(server, request, "Hello ${name}");
}

int main(argc, argv)
    int argc;
    char *argv[];
{
    httpd   *server;
    httpReq *request;
    struct timeval timeout;
    int result;

    /*
    ** Create a server and setup our logging
    */
    server = httpdCreate(NULL, 8080);
    if (server == NULL)
    {
        perror("Can't create server");
        exit(1);
    }
    httpdSetAccessLog(server, stdout);
    httpdSetErrorLog(server, stderr);

    /*
    ** Setup some content for the server
    */
    httpdAddCContent(server, "/", "index.html", HTTP_TRUE, NULL, index_html);
    httpdAddCContent(server, "/", "test2.html", HTTP_FALSE, NULL, test2_html);
    httpdAddStaticContent(server, "/", "test1.html", HTTP_FALSE, NULL, test1_html);
    httpdAddCContent(server, "/", "mjpeg", HTTP_TRUE, NULL, mjpeg_handler);
    httpdAddCContent(server, "/", "jpeg", HTTP_TRUE, NULL, jpeg_handler);

    /*
    ** Go into our service loop
    */
    while (1 == 1)
    {
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        request = httpdReadRequest(server, &timeout, &result);
        if (request == NULL && result == 0)
        {
            /* Timed out. Go do something else if needed */
            continue;
        }

        if (result < 0)
        {
            /* Error occurred */
            continue;
        }
        httpdProcessRequest(server, request);
        httpdEndRequest(server, request);
    }
}